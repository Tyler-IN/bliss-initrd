#!/bin/busybox sh
set -eu

export PATH=/sbin:/bin
# make applet symlinks so scripts can call "mount", "unzip", etc.
[ -x /bin/busybox ] || { echo "no /bin/busybox"; exec sh; }
 /bin/busybox --install -s /bin

# Basic mounts
mount -t proc proc /proc
mount -t sysfs sys /sys
# Prefer devtmpfs; fall back to tmpfs + minimal nodes
if ! mount -t devtmpfs devtmpfs /dev 2>/dev/null; then
  mount -t tmpfs tmpfs /dev
  [ -e /dev/console ] || mknod -m 600 /dev/console c 5 1
  [ -e /dev/null   ] || mknod -m 666 /dev/null   c 1 3
  [ -e /dev/tty    ] || mknod -m 666 /dev/tty    c 5 0
fi

# Keep SELinux from getting in the way if present
if [ -e /sys/fs/selinux/enforce ]; then
  echo 0 > /sys/fs/selinux/enforce || true
fi

# --- locate magisk.apk (one-time, first boot) ---
APKFILE=""
for p in /magisk.apk /android*/magisk.apk /android-*/magisk.apk /mnt/android*/magisk.apk; do
  [ -f "$p" ] && { APKFILE="$p"; break; }
done

# Extract Magisk files for x86_64 into /magisk (idempotent)
mkdir -p /magisk
extract_one() { # src dst mode
  if unzip -l "$APKFILE" "$1" >/dev/null 2>&1; then
    unzip -p "$APKFILE" "$1" > "$2" && chmod "$3" "$2"
  fi
}

if [ -n "${APKFILE}" ]; then
  # core binaries (ELF in lib/x86_64)
  extract_one "lib/x86_64/libmagiskinit.so" "/magisk/magiskinit" 0755
  extract_one "lib/x86_64/libmagisk64.so"   "/magisk/magisk64"   0755
  # policy / rc / overlay; names can vary by Magisk version, try common ones:
  extract_one "assets/magiskpolicy"         "/magisk/magiskpolicy" 0755
  extract_one "assets/overlay.sh"           "/magisk/overlay.sh"   0755
  extract_one "assets/magisk.rc"            "/magisk/magisk.rc"    0644
  extract_one "assets/init.rc"              "/magisk/init.rc"      0644 || true
fi

# Minimal ABI env so helper scripts donâ€™t guess wrong
export ARCH=x86_64 ABI=x86_64 ABI32=x86 IS64BIT=true MAGISK_FILES_BASE=/magisk

# Run your magisk setup (patch rc/policy or stage files); safe if no-op
if [ -x /bin/magisk.sh ]; then
  /bin/magisk.sh || echo "magisk.sh returned nonzero, continuing"
fi

# --- chainload original initrd ---
# Unpack /initrd.img into /real, then switch_root to it
REAL=/real
mkdir -p "$REAL"
if [ -f /initrd.img ]; then
  ( cd "$REAL" && gzip -dc /initrd.img | cpio -idmv ) || {
    echo "failed to unpack initrd.img"; exec sh; }
else
  echo "initrd.img missing"; exec sh
fi

# Move our mounts over so /init can see devices and proc/sys
mkdir -p "$REAL"/{dev,proc,sys}
mount -o move /dev  "$REAL/dev"  2>/dev/null || true
mount -o move /proc "$REAL/proc" 2>/dev/null || true
mount -o move /sys  "$REAL/sys"  2>/dev/null || true

# Hand off to the original init
exec switch_root "$REAL" /init
